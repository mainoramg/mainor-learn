# Chapter 9: Exception Handling

## Table of Contents
* [The Exception Hierarchy](#the-exception-hierarchy)
* [Exception Handling Fundamentals](#exception-handling-fundamentals)
  * [Using try and catch](#using-try-and-catch)
  * [A Simple Exception Example](#a-simple-exception-example)
* [The Consequences of an Uncaught Exception](#the-consequences-of-an-uncaught-exception)
* [Using Multiple catch Statements](#using-multiple-catch-statements)
* [Catching Subclass Exceptions](#catching-subclass-exceptions)
* [Try Blocks Can Be Nested](#try-blocks-can-be-nested)
* [Throwing an Exception](#throwing-an-exception)
  * [Rethrowing an Exception](#rethrowing-an-exception)
* [A Closer Look at Throwable](#a-closer-look-at-throwable)
* [Using finally](#using-finally)
* [Using throws](#using-throws)
* [Three Recently Added Exception Features](#three-recently-added-exception-features)
* [Java's Built-in Exceptions](#javas-built-in-exceptions)
* [Creating Exception Subclasses](#creating-exception-subclasses)
* [Try This: Adding Exceptions to the Queue Class](#try-this-adding-exceptions-to-the-queue-class)

An exception is an error that occurs at run time. Using Java's exception handling subsystem you can, in a structured and controlled manner, handle run-time errors. Exception handling streamlines error handling by allowing your program to define a block of code, called an *exception handler*, that is executed automatically when an error occurs.

## The Exception Hierarchy

In Java, all exceptions are represented by classes. All exception classes are derived from a class called **Throwable**. Thus, when an exception occurs in a program, an object of some type of exception class is generated. There are two direct subclasses of **Throwable**: **Exception** and **Error**. Exceptions of type **Error** are related to errors that occur in the Java virtual machine itself, and not in your program. These types of exceptions are beyond your control, and your program will not usually deal with them.

Errors that result from program activity are represented by subclasses of **Exception**. For example, divide-by-zero, array boundary, and file errors fall into this category. In general, your program should handle exceptions of these types. An important subclass of **Exception** is **RuntimeException**, which is used to represent various common types of run-time errors.

## Exception Handling Fundamentals

Java exception handling is managed via five keywords: **try**, **catch**, **throw**, **throws**, and **finally**. They form an interrelated subsystem in which the use of one implies the use of another.

Program statements that you want to monitor for exceptions are contained within a **try** block. If an exception occurs within the **try** block, it is *thrown*. Your code can catch this exception using **catch** and handle it in some rational manner. System-generated exceptions are automatically thrown by the Java run-time system. To manually throw an exception, use the keyword **throw**. In some cases, an exception that is thrown out of a method must be specified as such by a **throws** clause. Any code that absolutely must be executed upon exiting from a **try** block is put in a **finally** block.

**Question: Just to be sure, could you review the conditions that cause an exception to be generated?**
**Answer**: Exceptions are generated in three different ways: 
1. The Java Virtual Machine can generate an exception in response to some internal error which is beyond your control. Normally, your program won't handle these types of exceptions.
2. Standard exceptions, such as those corresponding to divide-by-zero or array index out-of-bounds, are generated by errors in program code. You need to handle these exceptions.
3. You can manually generate an exception by using the **throw** statement. No matter how an exception is generated, it is handled in the same way.

### Using try and catch

At the core of exception handling are **try** and **catch**. These keywords work together; you can't have a **catch** without a **try**. Here is the general form of the **try**/**catch** exception handling blocks:
```text
try {
    // block of code to monitor for errors
}
catch (ExcepType1 exOb) {
    // handler for ExcepType1
}
catch (ExcepType2 exOb) {
    // handler for ExcepType2
}
.
.
.
```

As the general form shows, there can be more than one **catch** statement associated with a **try**. The type of the exception determines which **catch** statement is executed. That is, if the exception type specified by a **catch** statement matches that of the exception, then that **catch** statement is executed (and all others are bypassed).

Here is an important point: If no exception is thrown, then a **try** block ends normally, and all of its **catch** statements are bypassed.

**NOTE**: Beginning with JDK 7, there is another form of the **try** statement that supports *automatic resource management*. This form of **try** is called *try-with-resources*. It is described in Chapter 10, in the context of managing I/O streams (such as those connected to a file) because streams are some of the most commonly used resources.

### A Simple Exception Example

Here is a simple example that illustrates how to watch for and catch an exception. As you know, it is an error to attempt to index an array beyond its boundaries. When this occurs, the JVM throws an **ArrayIndexOutOfBoundsException**. The following program purposely generates such an exception and then catches it:
```java
class ExcDemo1 {
    public static void main(String[] args) {
        int[] nums = new int[4];
        try { // Create a try block
            System.out.println("Before exception is generated.");
            // Generate an index out-of-bounds exception
            nums[7] = 10; // Attempt to index past nums boundary
            System.out.println("this won't be displayed");
        }
        catch (ArrayIndexOutOfBoundsException exc) { // Catch array boundary errors
            // catch the exception
            System.out.println("Index out-of-bounds!");
        }
        System.out.println("After catch statement.");
    }
}
```

This program displays the following output:
```text
Before exception is generated.
Index out-of-bounds!
After catch statement.
```

It is important to understand that all code within a **try** block is monitored for exceptions. This includes exceptions that might be generated by a method called from within the **try** block. An exception thrown by a method called from within a **try** block can be caught by the **catch** statements associated with that **try** block—assuming, of course, that the method did not catch the exception itself. For example, this is a valid program:
```java
class ExcTest {
    // Generate an exception
    static void genException() {
        int[] nums = new int[4];

        System.out.println("Before exception is generated.");

        // Generate an index out-of-bounds exception
        nums[7] = 10; // Exception generated here
        System.out.println("this won't be displayed");
    }
}
class ExcDemo2 {
    public static void main(String[] args) {
        try {
            ExcTest.genException();
        }
        catch (ArrayIndexOutOfBoundsException exc) { // Exception caught here
            // catch the exception
            System.out.println("Index out-of-bounds!");
        }
        System.out.println("After catch statement.");
    }
}
```

This program produces the following output, which is the same as that produced by the first version of the program shown earlier:
```text
Before exception is generated.
Index out-of-bounds!
After catch statement.
```

Since **genException()** is called from within a **try** block, the exception that it generates (and does not catch) is caught by the **catch** in **main()**. Understand, however, that if **genException()** had caught the exception itself, it never would have been passed back to **main()**.

## The Consequences of an Uncaught Exception

Catching one of Java's standard exceptions, as the preceding program does, has a side benefit: It prevents abnormal program termination. When an exception is thrown, it must be caught by some piece of code, somewhere. In general, if your program does not catch an exception, then it will be caught by the JVM. The trouble is that the JVM's default exception handler terminates execution and displays a stack trace and error message. For example, in this version of the preceding example, the index out-of-bounds exception is not caught by the program.
```java
class NotHandled {
    public static void main(String[] args) {
        int[] nums = new int[4];

        System.out.println("Before exception is generated.");

        // Generate an index out-of-bounds exception
        nums[7] = 10;
    }
}
```

When the array index error occurs, execution is halted, and the following error message is displayed.
```text
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length 4
	at NotHandled.main(NotHandled.java:9)
```

While such a message is useful for you while debugging, it would not be something that you would want others to see, to say the least! This is why it is important for your program to handle exceptions itself, rather than rely upon the JVM.

As mentioned earlier, the type of the exception must match the type specified in a **catch** statement. If it doesn't, the exception won't be caught. For example, the following program tries to catch an array boundary error with a **catch** statement for an **ArithmeticException** (another of Java's built-in exceptions). When the array boundary is overrun, an **ArrayIndexOutOfBoundsException** is generated, but it won't be caught by the **catch** statement. This results in abnormal program termination.
```java
class ExcTypeMismatch {
    public static void main(String[] args) {
        int[] nums = new int[4];
        try {
            System.out.println("Before exception is generated.");

            // Generate an index out-of-bounds exception
            nums[7] = 10; // This throws an ArrayIndexOutOfBoundsException
            System.out.println("this won't be displayed");
        }
        // Can't catch an array boundary error with an ArithmeticException
        catch (ArithmeticException exc) { // This tries to catch it with an ArithmeticException
            // catch the exception
            System.out.println("Index out-of-bounds!");
        }
        System.out.println("After catch statement.");
    }
}
```

The output is shown here:
```text
Before exception is generated.
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length 4
	at ExcTypeMismatch.main(ExcTypeMismatch.java:10)
```

As the output demonstrates, a **catch** for **ArithmeticException** won't catch an **ArrayIndexOutOfBoundsException**.

## Using Multiple catch Statements

As stated earlier, you can associate more than one **catch** statement with a **try**. In fact, it is common to do so. However, each **catch** must catch a different type of exception. For example, the program shown here catches both array boundary and divide-by-zero errors:
```java
class ExcDemo4 {
    public static void main(String[] args) {
        // Here, numer is longer than denom
        int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
        int[] denom = { 2, 0, 4, 4, 0, 8 };

        for (int i = 0; i < numer.length; i++) {
            try {
                System.out.println(numer[i] + " / " + denom[i] + " is " + numer[i]/denom[i]);
            }
            catch (ArithmeticException exc) { // Multiple catch statements
                // catch the exception
                System.out.println("Can't divide by Zero!");
            }
            catch (ArrayIndexOutOfBoundsException exc) { // Multiple catch statements
                // catch the exception
                System.out.println("No matching element found.");
            }
        }
    }
}
```

This program produces the following output:
```text
4 / 2 is 2
Can't divide by Zero!
16 / 4 is 4
32 / 4 is 8
Can't divide by Zero!
128 / 8 is 16
No matching element found.
No matching element found.
```

As the output confirms, each **catch** statement responds only to its own type of exception.

In general, **catch** expressions are checked in the order in which they occur in a program. Only a matching statement is executed. All other **catch** blocks are ignored.

## Catching Subclass Exceptions

There is one important point about multiple **catch** statements that relates to subclasses. A **catch** clause for a superclass will also match any of its subclasses. For example, since the superclass of all exceptions is **Throwable**, to catch all possible exceptions, catch **Throwable**. If you want to catch exceptions of both a superclass type and a subclass type, put the subclass first in the **catch** sequence. If you don't, then the superclass **catch** will also catch all derived classes. This rule is self-enforcing because putting the superclass first causes unreachable code to be created, since the subclass **catch** clause can never execute. In Java, unreachable code is an error.

For example, consider the following program:
```java
class ExcDemo5 {
    public static void main(String[] args) {
        // Here, numer is longer than denom
        int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
        int[] denom = { 2, 0, 4, 4, 0, 8 };

        for (int i = 0; i < numer.length; i++) {
            try {
                System.out.println(numer[i] + " / " + denom[i] + " is " + numer[i]/denom[i]);
            }
            catch (ArrayIndexOutOfBoundsException exc) { // Catch subclass
                // catch the exception
                System.out.println("No matching element found.");
            }
            catch (Throwable exc) { // Catch superclass
                System.out.println("Some exception occurred.");
            }
        }
    }
}
```

The output from the program is shown here:
```text
4 / 2 is 2
Some exception occurred.
16 / 4 is 4
32 / 4 is 8
Some exception occurred.
128 / 8 is 16
No matching element found.
No matching element found.
```

**Question: Why would I want to catch superclass exceptions?**
**Answer**: There are, of course, a variety of reasons. Here are a couple:
1. If you add a **catch** clause that catches exceptions of type **Exception**, then you have effectively added a "catch all" clause to your exception handler that deals with all program-related exceptions. Such a "catch all" clause might be useful in a situation in which abnormal program termination must be avoided no matter what occurs.
2. In some situations, an entire category of exceptions can be handled by the same clause. Catching the superclass of these exceptions allows you to handle all without duplicated code.

In this case, **catch(Throwable)** catches all exceptions except for **ArrayIndexOutOfBounds-Exception**. The issue of catching subclass exceptions becomes more important when you create exceptions of your own.

## Try Blocks Can Be Nested

One **try** block can be nested within another. An exception generated within the inner **try** block that is not caught by a **catch** associated with that **try** is propagated to the outer **try** block. For example, here the **ArrayIndexOutOfBoundsException** is not caught by the inner **catch**, but by the outer **catch**:
```java
class NestTrys {
    public static void main(String[] args) {
        // Here, numer is longer than denom
        int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
        int[] denom = { 2, 0, 4, 4, 0, 8 };

        try { // outer try
            for (int i = 0; i < numer.length; i++) {
                try { // nested try
                    System.out.println(numer[i] + " / " + denom[i] + " is " + numer[i]/denom[i]);
                }
                catch (ArithmeticException exc) {
                    // catch the exception
                    System.out.println("Can't divide by Zero!");
                }
            }
        }
        catch (ArrayIndexOutOfBoundsException exc) {
            // catch the exception
            System.out.println("No matching element found.");
            System.out.println("Fatal error - program terminated.");
        }
    }
}
```

The output from the program is shown here:
```text
4 / 2 is 2
Can't divide by Zero!
16 / 4 is 4
32 / 4 is 8
Can't divide by Zero!
128 / 8 is 16
No matching element found.
Fatal error - program terminated.
```

In this example, an exception that can be handled by the inner **try**—in this case, a divide-by-zero error—allows the program to continue. However, an array boundary error is caught by the outer **try**, which causes the program to terminate.

Although certainly not the only reason for nested **try** statements, the preceding program makes an important point that can be generalized. Often nested **try** blocks are used to allow different categories of errors to be handled in different ways. Some types of errors are catastrophic and cannot be fixed. Some are minor and can be handled immediately. You might use an outer **try** block to catch the most severe errors, allowing inner **try** blocks to handle less serious ones.

## Throwing an Exception

The preceding examples have been catching exceptions generated automatically by the JVM. However, it is possible to manually throw an exception by using the **throw** statement. Its general form is shown here:
```text
throw exceptOb; 
```

Here, *exceptOb* must be an object of an exception class derived from **Throwable**.

Here is an example that illustrates the **throw** statement by manually throwing an **ArithmeticException**:
```java
class ThrowDemo {
    public static void main(String[] args) {
        try {
            System.out.println("Before throw.");
            throw new ArithmeticException(); // Throw an exception
        }
        catch (ArithmeticException exc) {
            // catch the exception
            System.out.println("Exception caught.");
        }
        System.out.println("After try/catch block.");
    }
}
```

The output from the program is shown here:
```text
Before throw.
Exception caught.
After try/catch block.
```

Notice how the **ArithmeticException** was created using **new** in the **throw** statement. Remember, **throw** throws an object. Thus, you must create an object for it to throw. That is, you can't just throw a type.

**Question: Why would I want to manually throw an exception?**
**Answer**: Most often, the exceptions that you will throw will be instances of exception classes that you created. As you will see later in this chapter, creating your own exception classes allows you to handle errors in your code as part of your program's overall exception handling strategy.

### Rethrowing an Exception

An exception caught by one **catch** statement can be rethrown so that it can be caught by an outer **catch**. The most likely reason for rethrowing this way is to allow multiple handlers access to the exception. For example, perhaps one exception handler manages one aspect of an exception, and a second handler copes with another aspect. Remember, when you rethrow an exception, it will not be recaught by the same **catch** statement. It will propagate to the next **catch** statement. The following program illustrates rethrowing an exception:
```java
class Rethrow {
    public static void genException() {
        // Here, numer is longer than denom
        int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
        int[] denom = { 2, 0, 4, 4, 0, 8 };

        for (int i = 0; i < numer.length; i++) {
            try {
                System.out.println(numer[i] + " / " + denom[i] + " is " + numer[i]/denom[i]);
            }
            catch (ArithmeticException exc) {
                // catch the exception
                System.out.println("Can't divide by Zero!");
            }
            catch (ArrayIndexOutOfBoundsException exc) {
                // catch the exception
                System.out.println("No matching element found.");
                throw exc; // Rethrow the exception
            }
        }
    }
}
class RethrowDemo {
    public static void main(String[] args) {
        try {
            Rethrow.genException();
        }
        catch (ArrayIndexOutOfBoundsException exc) { // Catch rethrown exception
            // recatch exception
            System.out.println("Fatal error - program terminated.");
        }
    }
}
```

In this program, divide-by-zero errors are handled locally, by **genException()**, but an array boundary error is rethrown. In this case, it is caught by **main()**.

## A Closer Look at Throwable

Pending.

## Using finally

Pending.

## Using throws

Pending.

## Three Recently Added Exception Features

Pending.

## Java's Built-in Exceptions

Pending.

## Creating Exception Subclasses

Pending.

## Try This: Adding Exceptions to the Queue Class

Pending.