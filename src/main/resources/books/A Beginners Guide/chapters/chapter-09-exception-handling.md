# Chapter 9: Exception Handling

## Table of Contents
* [The Exception Hierarchy](#the-exception-hierarchy)
* [Exception Handling Fundamentals](#exception-handling-fundamentals)
  * [Using try and catch](#using-try-and-catch)
  * [A Simple Exception Example](#a-simple-exception-example)
* [The Consequences of an Uncaught Exception](#the-consequences-of-an-uncaught-exception)
* [Using Multiple catch Statements](#using-multiple-catch-statements)
* [Catching Subclass Exceptions](#catching-subclass-exceptions)
* [Try Blocks Can Be Nested](#try-blocks-can-be-nested)
* [Throwing an Exception](#throwing-an-exception)
  * [Rethrowing an Exception](#rethrowing-an-exception)
* [A Closer Look at Throwable](#a-closer-look-at-throwable)
* [Using finally](#using-finally)
* [Using throws](#using-throws)
* [Three Recently Added Exception Features](#three-recently-added-exception-features)
* [Java's Built-in Exceptions](#javas-built-in-exceptions)
* [Creating Exception Subclasses](#creating-exception-subclasses)
* [Try This: Adding Exceptions to the Queue Class](#try-this-adding-exceptions-to-the-queue-class)

An exception is an error that occurs at run time. Using Java's exception handling subsystem you can, in a structured and controlled manner, handle run-time errors. Exception handling streamlines error handling by allowing your program to define a block of code, called an *exception handler*, that is executed automatically when an error occurs.

## The Exception Hierarchy

In Java, all exceptions are represented by classes. All exception classes are derived from a class called **Throwable**. Thus, when an exception occurs in a program, an object of some type of exception class is generated. There are two direct subclasses of **Throwable**: **Exception** and **Error**. Exceptions of type **Error** are related to errors that occur in the Java virtual machine itself, and not in your program. These types of exceptions are beyond your control, and your program will not usually deal with them.

Errors that result from program activity are represented by subclasses of **Exception**. For example, divide-by-zero, array boundary, and file errors fall into this category. In general, your program should handle exceptions of these types. An important subclass of **Exception** is **RuntimeException**, which is used to represent various common types of run-time errors.

## Exception Handling Fundamentals

Java exception handling is managed via five keywords: **try**, **catch**, **throw**, **throws**, and **finally**. They form an interrelated subsystem in which the use of one implies the use of another.

Program statements that you want to monitor for exceptions are contained within a **try** block. If an exception occurs within the **try** block, it is *thrown*. Your code can catch this exception using **catch** and handle it in some rational manner. System-generated exceptions are automatically thrown by the Java run-time system. To manually throw an exception, use the keyword **throw**. In some cases, an exception that is thrown out of a method must be specified as such by a **throws** clause. Any code that absolutely must be executed upon exiting from a **try** block is put in a **finally** block.

**Question: Just to be sure, could you review the conditions that cause an exception to be generated?**
**Answer**: Exceptions are generated in three different ways: 
1. The Java Virtual Machine can generate an exception in response to some internal error which is beyond your control. Normally, your program won't handle these types of exceptions.
2. Standard exceptions, such as those corresponding to divide-by-zero or array index out-of-bounds, are generated by errors in program code. You need to handle these exceptions.
3. You can manually generate an exception by using the **throw** statement. No matter how an exception is generated, it is handled in the same way.

### Using try and catch

At the core of exception handling are **try** and **catch**. These keywords work together; you can't have a **catch** without a **try**. Here is the general form of the **try**/**catch** exception handling blocks:
```text
try {
    // block of code to monitor for errors
}
catch (ExcepType1 exOb) {
    // handler for ExcepType1
}
catch (ExcepType2 exOb) {
    // handler for ExcepType2
}
.
.
.
```

As the general form shows, there can be more than one **catch** statement associated with a **try**. The type of the exception determines which **catch** statement is executed. That is, if the exception type specified by a **catch** statement matches that of the exception, then that **catch** statement is executed (and all others are bypassed).

Here is an important point: If no exception is thrown, then a **try** block ends normally, and all of its **catch** statements are bypassed.

**NOTE**: Beginning with JDK 7, there is another form of the **try** statement that supports *automatic resource management*. This form of **try** is called *try-with-resources*. It is described in Chapter 10, in the context of managing I/O streams (such as those connected to a file) because streams are some of the most commonly used resources.

### A Simple Exception Example

Here is a simple example that illustrates how to watch for and catch an exception. As you know, it is an error to attempt to index an array beyond its boundaries. When this occurs, the JVM throws an **ArrayIndexOutOfBoundsException**. The following program purposely generates such an exception and then catches it:
```java
class ExcDemo1 {
    public static void main(String[] args) {
        int[] nums = new int[4];
        try { // Create a try block
            System.out.println("Before exception is generated.");
            // Generate an index out-of-bounds exception
            nums[7] = 10; // Attempt to index past nums boundary
            System.out.println("this won't be displayed");
        }
        catch (ArrayIndexOutOfBoundsException exc) { // Catch array boundary errors
            // catch the exception
            System.out.println("Index out-of-bounds!");
        }
        System.out.println("After catch statement.");
    }
}
```

This program displays the following output:
```text
Before exception is generated.
Index out-of-bounds!
After catch statement.
```

## The Consequences of an Uncaught Exception

Pending.

## Using Multiple catch Statements

Pending.

## Catching Subclass Exceptions

Pending.

## Try Blocks Can Be Nested

Pending.

## Throwing an Exception

Pending.

### Rethrowing an Exception

Pending.

## A Closer Look at Throwable

Pending.

## Using finally

Pending.

## Using throws

Pending.

## Three Recently Added Exception Features

Pending.

## Java's Built-in Exceptions

Pending.

## Creating Exception Subclasses

Pending.

## Try This: Adding Exceptions to the Queue Class

Pending.