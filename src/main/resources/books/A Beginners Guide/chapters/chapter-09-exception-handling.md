# Chapter 9: Exception Handling

## Table of Contents
* [The Exception Hierarchy](#the-exception-hierarchy)
* [Exception Handling Fundamentals](#exception-handling-fundamentals)
  * [Using try and catch](#using-try-and-catch)
  * [A Simple Exception Example](#a-simple-exception-example)
* [The Consequences of an Uncaught Exception](#the-consequences-of-an-uncaught-exception)
* [Using Multiple catch Statements](#using-multiple-catch-statements)
* [Catching Subclass Exceptions](#catching-subclass-exceptions)
* [Try Blocks Can Be Nested](#try-blocks-can-be-nested)
* [Throwing an Exception](#throwing-an-exception)
  * [Rethrowing an Exception](#rethrowing-an-exception)
* [A Closer Look at Throwable](#a-closer-look-at-throwable)
* [Using finally](#using-finally)
* [Using throws](#using-throws)
* [Three Recently Added Exception Features](#three-recently-added-exception-features)
  * [Multi-catch](#multi-catch)
  * [More Precise Rethrow](#more-precise-rethrow)
* [Java's Built-in Exceptions](#javas-built-in-exceptions)
* [Creating Exception Subclasses](#creating-exception-subclasses)

An exception is an error that occurs at run time. Using Java's exception handling subsystem you can, in a structured and controlled manner, handle run-time errors. Exception handling streamlines error handling by allowing your program to define a block of code, called an *exception handler*, that is executed automatically when an error occurs.

## The Exception Hierarchy

In Java, all exceptions are represented by classes. All exception classes are derived from a class called **Throwable**. Thus, when an exception occurs in a program, an object of some type of exception class is generated. There are two direct subclasses of **Throwable**: **Exception** and **Error**. Exceptions of type **Error** are related to errors that occur in the Java virtual machine itself, and not in your program. These types of exceptions are beyond your control, and your program will not usually deal with them.

Errors that result from program activity are represented by subclasses of **Exception**. For example, divide-by-zero, array boundary, and file errors fall into this category. In general, your program should handle exceptions of these types. An important subclass of **Exception** is **RuntimeException**, which is used to represent various common types of run-time errors.

## Exception Handling Fundamentals

Java exception handling is managed via five keywords: **try**, **catch**, **throw**, **throws**, and **finally**. They form an interrelated subsystem in which the use of one implies the use of another.

Program statements that you want to monitor for exceptions are contained within a **try** block. If an exception occurs within the **try** block, it is *thrown*. Your code can catch this exception using **catch** and handle it in some rational manner. System-generated exceptions are automatically thrown by the Java run-time system. To manually throw an exception, use the keyword **throw**. In some cases, an exception that is thrown out of a method must be specified as such by a **throws** clause. Any code that absolutely must be executed upon exiting from a **try** block is put in a **finally** block.

**Question: Just to be sure, could you review the conditions that cause an exception to be generated?**
**Answer**: Exceptions are generated in three different ways: 
1. The Java Virtual Machine can generate an exception in response to some internal error which is beyond your control. Normally, your program won't handle these types of exceptions.
2. Standard exceptions, such as those corresponding to divide-by-zero or array index out-of-bounds, are generated by errors in program code. You need to handle these exceptions.
3. You can manually generate an exception by using the **throw** statement. No matter how an exception is generated, it is handled in the same way.

### Using try and catch

At the core of exception handling are **try** and **catch**. These keywords work together; you can't have a **catch** without a **try**. Here is the general form of the **try**/**catch** exception handling blocks:
```text
try {
    // block of code to monitor for errors
}
catch (ExcepType1 exOb) {
    // handler for ExcepType1
}
catch (ExcepType2 exOb) {
    // handler for ExcepType2
}
.
.
.
```

As the general form shows, there can be more than one **catch** statement associated with a **try**. The type of the exception determines which **catch** statement is executed. That is, if the exception type specified by a **catch** statement matches that of the exception, then that **catch** statement is executed (and all others are bypassed).

Here is an important point: If no exception is thrown, then a **try** block ends normally, and all of its **catch** statements are bypassed.

**NOTE**: Beginning with JDK 7, there is another form of the **try** statement that supports *automatic resource management*. This form of **try** is called *try-with-resources*. It is described in Chapter 10, in the context of managing I/O streams (such as those connected to a file) because streams are some of the most commonly used resources.

### A Simple Exception Example

Here is a simple example that illustrates how to watch for and catch an exception. As you know, it is an error to attempt to index an array beyond its boundaries. When this occurs, the JVM throws an **ArrayIndexOutOfBoundsException**. The following program purposely generates such an exception and then catches it:
```java
class ExcDemo1 {
    public static void main(String[] args) {
        int[] nums = new int[4];
        try { // Create a try block
            System.out.println("Before exception is generated.");
            // Generate an index out-of-bounds exception
            nums[7] = 10; // Attempt to index past nums boundary
            System.out.println("this won't be displayed");
        }
        catch (ArrayIndexOutOfBoundsException exc) { // Catch array boundary errors
            // catch the exception
            System.out.println("Index out-of-bounds!");
        }
        System.out.println("After catch statement.");
    }
}
```

This program displays the following output:
```text
Before exception is generated.
Index out-of-bounds!
After catch statement.
```

It is important to understand that all code within a **try** block is monitored for exceptions. This includes exceptions that might be generated by a method called from within the **try** block. An exception thrown by a method called from within a **try** block can be caught by the **catch** statements associated with that **try** block—assuming, of course, that the method did not catch the exception itself. For example, this is a valid program:
```java
class ExcTest {
    // Generate an exception
    static void genException() {
        int[] nums = new int[4];

        System.out.println("Before exception is generated.");

        // Generate an index out-of-bounds exception
        nums[7] = 10; // Exception generated here
        System.out.println("this won't be displayed");
    }
}
class ExcDemo2 {
    public static void main(String[] args) {
        try {
            ExcTest.genException();
        }
        catch (ArrayIndexOutOfBoundsException exc) { // Exception caught here
            // catch the exception
            System.out.println("Index out-of-bounds!");
        }
        System.out.println("After catch statement.");
    }
}
```

This program produces the following output, which is the same as that produced by the first version of the program shown earlier:
```text
Before exception is generated.
Index out-of-bounds!
After catch statement.
```

Since **genException()** is called from within a **try** block, the exception that it generates (and does not catch) is caught by the **catch** in **main()**. Understand, however, that if **genException()** had caught the exception itself, it never would have been passed back to **main()**.

## The Consequences of an Uncaught Exception

Catching one of Java's standard exceptions, as the preceding program does, has a side benefit: It prevents abnormal program termination. When an exception is thrown, it must be caught by some piece of code, somewhere. In general, if your program does not catch an exception, then it will be caught by the JVM. The trouble is that the JVM's default exception handler terminates execution and displays a stack trace and error message. For example, in this version of the preceding example, the index out-of-bounds exception is not caught by the program.
```java
class NotHandled {
    public static void main(String[] args) {
        int[] nums = new int[4];

        System.out.println("Before exception is generated.");

        // Generate an index out-of-bounds exception
        nums[7] = 10;
    }
}
```

When the array index error occurs, execution is halted, and the following error message is displayed.
```text
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length 4
	at NotHandled.main(NotHandled.java:9)
```

While such a message is useful for you while debugging, it would not be something that you would want others to see, to say the least! This is why it is important for your program to handle exceptions itself, rather than rely upon the JVM.

As mentioned earlier, the type of the exception must match the type specified in a **catch** statement. If it doesn't, the exception won't be caught. For example, the following program tries to catch an array boundary error with a **catch** statement for an **ArithmeticException** (another of Java's built-in exceptions). When the array boundary is overrun, an **ArrayIndexOutOfBoundsException** is generated, but it won't be caught by the **catch** statement. This results in abnormal program termination.
```java
class ExcTypeMismatch {
    public static void main(String[] args) {
        int[] nums = new int[4];
        try {
            System.out.println("Before exception is generated.");

            // Generate an index out-of-bounds exception
            nums[7] = 10; // This throws an ArrayIndexOutOfBoundsException
            System.out.println("this won't be displayed");
        }
        // Can't catch an array boundary error with an ArithmeticException
        catch (ArithmeticException exc) { // This tries to catch it with an ArithmeticException
            // catch the exception
            System.out.println("Index out-of-bounds!");
        }
        System.out.println("After catch statement.");
    }
}
```

The output is shown here:
```text
Before exception is generated.
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length 4
	at ExcTypeMismatch.main(ExcTypeMismatch.java:10)
```

As the output demonstrates, a **catch** for **ArithmeticException** won't catch an **ArrayIndexOutOfBoundsException**.

## Using Multiple catch Statements

As stated earlier, you can associate more than one **catch** statement with a **try**. In fact, it is common to do so. However, each **catch** must catch a different type of exception. For example, the program shown here catches both array boundary and divide-by-zero errors:
```java
class ExcDemo4 {
    public static void main(String[] args) {
        // Here, numer is longer than denom
        int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
        int[] denom = { 2, 0, 4, 4, 0, 8 };

        for (int i = 0; i < numer.length; i++) {
            try {
                System.out.println(numer[i] + " / " + denom[i] + " is " + numer[i]/denom[i]);
            }
            catch (ArithmeticException exc) { // Multiple catch statements
                // catch the exception
                System.out.println("Can't divide by Zero!");
            }
            catch (ArrayIndexOutOfBoundsException exc) { // Multiple catch statements
                // catch the exception
                System.out.println("No matching element found.");
            }
        }
    }
}
```

This program produces the following output:
```text
4 / 2 is 2
Can't divide by Zero!
16 / 4 is 4
32 / 4 is 8
Can't divide by Zero!
128 / 8 is 16
No matching element found.
No matching element found.
```

As the output confirms, each **catch** statement responds only to its own type of exception.

In general, **catch** expressions are checked in the order in which they occur in a program. Only a matching statement is executed. All other **catch** blocks are ignored.

## Catching Subclass Exceptions

There is one important point about multiple **catch** statements that relates to subclasses. A **catch** clause for a superclass will also match any of its subclasses. For example, since the superclass of all exceptions is **Throwable**, to catch all possible exceptions, catch **Throwable**. If you want to catch exceptions of both a superclass type and a subclass type, put the subclass first in the **catch** sequence. If you don't, then the superclass **catch** will also catch all derived classes. This rule is self-enforcing because putting the superclass first causes unreachable code to be created, since the subclass **catch** clause can never execute. In Java, unreachable code is an error.

For example, consider the following program:
```java
class ExcDemo5 {
    public static void main(String[] args) {
        // Here, numer is longer than denom
        int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
        int[] denom = { 2, 0, 4, 4, 0, 8 };

        for (int i = 0; i < numer.length; i++) {
            try {
                System.out.println(numer[i] + " / " + denom[i] + " is " + numer[i]/denom[i]);
            }
            catch (ArrayIndexOutOfBoundsException exc) { // Catch subclass
                // catch the exception
                System.out.println("No matching element found.");
            }
            catch (Throwable exc) { // Catch superclass
                System.out.println("Some exception occurred.");
            }
        }
    }
}
```

The output from the program is shown here:
```text
4 / 2 is 2
Some exception occurred.
16 / 4 is 4
32 / 4 is 8
Some exception occurred.
128 / 8 is 16
No matching element found.
No matching element found.
```

**Question: Why would I want to catch superclass exceptions?**
**Answer**: There are, of course, a variety of reasons. Here are a couple:
1. If you add a **catch** clause that catches exceptions of type **Exception**, then you have effectively added a "catch all" clause to your exception handler that deals with all program-related exceptions. Such a "catch all" clause might be useful in a situation in which abnormal program termination must be avoided no matter what occurs.
2. In some situations, an entire category of exceptions can be handled by the same clause. Catching the superclass of these exceptions allows you to handle all without duplicated code.

In this case, **catch(Throwable)** catches all exceptions except for **ArrayIndexOutOfBounds-Exception**. The issue of catching subclass exceptions becomes more important when you create exceptions of your own.

## Try Blocks Can Be Nested

One **try** block can be nested within another. An exception generated within the inner **try** block that is not caught by a **catch** associated with that **try** is propagated to the outer **try** block. For example, here the **ArrayIndexOutOfBoundsException** is not caught by the inner **catch**, but by the outer **catch**:
```java
class NestTrys {
    public static void main(String[] args) {
        // Here, numer is longer than denom
        int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
        int[] denom = { 2, 0, 4, 4, 0, 8 };

        try { // outer try
            for (int i = 0; i < numer.length; i++) {
                try { // nested try
                    System.out.println(numer[i] + " / " + denom[i] + " is " + numer[i]/denom[i]);
                }
                catch (ArithmeticException exc) {
                    // catch the exception
                    System.out.println("Can't divide by Zero!");
                }
            }
        }
        catch (ArrayIndexOutOfBoundsException exc) {
            // catch the exception
            System.out.println("No matching element found.");
            System.out.println("Fatal error - program terminated.");
        }
    }
}
```

The output from the program is shown here:
```text
4 / 2 is 2
Can't divide by Zero!
16 / 4 is 4
32 / 4 is 8
Can't divide by Zero!
128 / 8 is 16
No matching element found.
Fatal error - program terminated.
```

In this example, an exception that can be handled by the inner **try**—in this case, a divide-by-zero error—allows the program to continue. However, an array boundary error is caught by the outer **try**, which causes the program to terminate.

Although certainly not the only reason for nested **try** statements, the preceding program makes an important point that can be generalized. Often nested **try** blocks are used to allow different categories of errors to be handled in different ways. Some types of errors are catastrophic and cannot be fixed. Some are minor and can be handled immediately. You might use an outer **try** block to catch the most severe errors, allowing inner **try** blocks to handle less serious ones.

## Throwing an Exception

The preceding examples have been catching exceptions generated automatically by the JVM. However, it is possible to manually throw an exception by using the **throw** statement. Its general form is shown here:
```text
throw exceptOb; 
```

Here, *exceptOb* must be an object of an exception class derived from **Throwable**.

Here is an example that illustrates the **throw** statement by manually throwing an **ArithmeticException**:
```java
class ThrowDemo {
    public static void main(String[] args) {
        try {
            System.out.println("Before throw.");
            throw new ArithmeticException(); // Throw an exception
        }
        catch (ArithmeticException exc) {
            // catch the exception
            System.out.println("Exception caught.");
        }
        System.out.println("After try/catch block.");
    }
}
```

The output from the program is shown here:
```text
Before throw.
Exception caught.
After try/catch block.
```

Notice how the **ArithmeticException** was created using **new** in the **throw** statement. Remember, **throw** throws an object. Thus, you must create an object for it to throw. That is, you can't just throw a type.

**Question: Why would I want to manually throw an exception?**
**Answer**: Most often, the exceptions that you will throw will be instances of exception classes that you created. As you will see later in this chapter, creating your own exception classes allows you to handle errors in your code as part of your program's overall exception handling strategy.

### Rethrowing an Exception

An exception caught by one **catch** statement can be rethrown so that it can be caught by an outer **catch**. The most likely reason for rethrowing this way is to allow multiple handlers access to the exception. For example, perhaps one exception handler manages one aspect of an exception, and a second handler copes with another aspect. Remember, when you rethrow an exception, it will not be recaught by the same **catch** statement. It will propagate to the next **catch** statement. The following program illustrates rethrowing an exception:
```java
class Rethrow {
    public static void genException() {
        // Here, numer is longer than denom
        int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };
        int[] denom = { 2, 0, 4, 4, 0, 8 };

        for (int i = 0; i < numer.length; i++) {
            try {
                System.out.println(numer[i] + " / " + denom[i] + " is " + numer[i]/denom[i]);
            }
            catch (ArithmeticException exc) {
                // catch the exception
                System.out.println("Can't divide by Zero!");
            }
            catch (ArrayIndexOutOfBoundsException exc) {
                // catch the exception
                System.out.println("No matching element found.");
                throw exc; // Rethrow the exception
            }
        }
    }
}
class RethrowDemo {
    public static void main(String[] args) {
        try {
            Rethrow.genException();
        }
        catch (ArrayIndexOutOfBoundsException exc) { // Catch rethrown exception
            // recatch exception
            System.out.println("Fatal error - program terminated.");
        }
    }
}
```

In this program, divide-by-zero errors are handled locally, by **genException()**, but an array boundary error is rethrown. In this case, it is caught by **main()**.

## A Closer Look at Throwable

Since all exceptions are subclasses of **Throwable**, all exceptions support the methods defined by **Throwable**. Several commonly used ones are shown in next table.

Method | Description
------ | -----------
Throwable fillInStackTrace() | Returns a **Throwable** object that contains a completed stack trace. This object can be rethrown.
String getLocalizedMessage() | Returns a localized description of the exception.
String getMessage() | Returns a description of the exception.
void printStackTrace() | Displays the stack trace.
void printStackTrace(PrintStream *stream*) | Sends the stack trace to the specified stream.
void printStackTrace(PrintWriter *stream*) | Sends the stack trace to the specified stream.
String toString() | Returns a **String** object containing a complete description of the exception. This method is called by **println()** when outputting a **Throwable** object. 

Of the methods defined by **Throwable**, two of the most interesting are **printStackTrace()** and **toString()**. You can display the standard error message plus a record of the method calls that lead up to the exception by calling **printStackTrace()**. You can use **toString()** to retrieve the standard error message. The **toString()** method is also called when an exception is used as an argument to **println()**. The following program demonstrates these methods:
```java
class ExcTest {
    static void genException() {
        int[] nums =  new int[4];

        System.out.println("Before exception is generated.");

        // generate an index out-of-bounds exception
        nums[7] = 10;
        System.out.println("this won't be displayed");
    }
}
class UseThrowableMethods {
    public static void main(String[] args) {
        try {
            ExcTest.genException();
        }
        catch (ArrayIndexOutOfBoundsException exc) {
            // catch the exception
            System.out.println("Standard message is: ");
            System.out.println(exc);
            System.out.println("\nStack trace:");
            exc.printStackTrace();
        }
        System.out.println("After catch statement.");
    }
}
```

The output from the program is shown here:
```text
Before exception is generated.
Standard message is: 
java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length 4

Stack trace:
java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length 4
	at ExcTest.genException(UseThrowableMethods.java:10)
	at UseThrowableMethods.main(UseThrowableMethods.java:19)
After catch statement.
```

## Using finally

To specify a block of code to execute when a **try**/**catch** block is exited, include a **finally** block at the end of a **try**/**catch** sequence. The general form of a **try**/**catch** that includes **finally** is shown here.
```java
try {
    // block of code to monitor for errors
}
catch (ExcepType1 exOb) {
    // handler for ExcepType1
}
catch (ExcepType2 exOb) {
    // handler for ExcepType2
}
// ...
finally {
    // finally code
}
```

The **finally** block will be executed whenever execution leaves a **try**/**catch** block, no matter what conditions cause it. That is, whether the **try** block ends normally, or because of an exception, the last code executed is that defined by **finally**. The **finally** block is also executed if any code within the **try** block or any of its **catch** statements return from the method.

Here is an example of **finally**:
```java
class UseFinally {
    public static void genException(int what) {
        int t;
        int[] nums =  new int[2];

        System.out.println("Receiving " + what);
        try {
            switch (what) {
                case 0:
                    t = 10 / what; // generate div-by-zero error
                    break;
                case 1:
                    nums[4] = 4; // generate array index error
                    break;
                case 2:
                    return; // return from try block
            }
        }
        catch (ArithmeticException exc) {
            // catch the exception
            System.out.println("Can't divide by Zero!");
            return; // return from catch
        }
        catch (ArrayIndexOutOfBoundsException exc) {
            // catch the exception
            System.out.println("No matching element found.");
        }
        finally { // This is executed on the way out of try/catch blocks
            System.out.println("Leaving try.");
        }
    }
}
class FinallyDemo {
    public static void main(String[] args) {
        for (int i = 0; i < 3; i++) {
            UseFinally.genException(i);
            System.out.println();
        }
    }
}
```

Here is the output produced by the program:
```text
Receiving 0
Can't divide by Zero!
Leaving try.

Receiving 1
No matching element found.
Leaving try.

Receiving 2
Leaving try.
```

As the output shows, no matter how the **try** block is exited, the **finally** block is executed.

## Using throws

In some cases, if a method generates an exception that it does not handle, it must declare that exception in a **throws** clause. Here is the general form of a method that includes a **throws** clause:
```text
ret-type methName(param-list) throws except-list {
    // body
}
```

Here, *except-list* is a comma-separated list of exceptions that the method might throw outside of itself.

You might be wondering why you did not need to specify a **throws** clause for some of the preceding examples, which threw exceptions outside of methods. The answer is that exceptions that are subclasses of **Error** or **RuntimeException** don't need to be specified in a **throws** list. Java simply assumes that a method may throw one. All other types of exceptions *do* need to be declared. Failure to do so causes a compile-time error.

Actually, you saw an example of a **throws** clause earlier in this book. As you will recall, when performing keyboard input, you needed to add the clause `throws java.io.IOException` to **main()**. Now you can understand why. An input statement might generate an **IOException**, and at that time, we weren't able to handle that exception. Thus, such an exception would be thrown out of **main()** and needed to be specified as such. Now that you know about exceptions, you can easily handle **IOException**.

Let's look at an example that handles **IOException**. It creates a method called **prompt()**, which displays a prompting message and then reads a character from the keyboard. Since input is being performed, an **IOException** might occur. However, the **prompt()** method does not handle **IOException** itself. Instead, it uses a throws clause, which means that the calling method must handle it. In this example, the calling method is **main()**, and it deals with the error.
```java
class ThrowsDemo {
    public static char prompt(String str)
        throws java.io.IOException { // Notice the throws
        
        System.out.println(str + ": ");
        return (char) System.in.read();
    }

    public static void main(String[] args) {
        char ch;
        
        try {
            ch = prompt("Enter a letter"); /* Since prompt() might throw an exception, a call
                                                  to it must be enclosed within a try block */
        }
        catch (java.io.IOException exc) {
            System.out.println("I/O exception occurred.");
            ch = 'X';
        }

        System.out.println("You pressed " + ch);
    }
}
```

## Three Recently Added Exception Features

Beginning with JDK 7, Java's exception handling mechanism was expanded with the addition of three features:
1. The first supports *automatic resource management*, which automates the process of releasing a resource, such as a file, when it is no longer needed. It is based on an expanded form of **try**, called the *try-with-resources* statement, and it is described in Chapter 10, when files are discussed.
2. The second new feature is called *multi-catch*.
3. The third is sometimes called *final rethrow* or *more precise rethrow*.

### Multi-catch

Multi-catch allows two or more exceptions to be caught by the same **catch** clause. As you learned earlier, it is possible (indeed, common) for a **try** to be followed by two or more **catch** clauses. Although each **catch** clause often supplies its own unique code sequence, it is not uncommon to have situations in which two or more **catch** clauses execute *the same code sequence* even though they catch different exceptions. Instead of having to catch each exception type individually, you can use a single **catch** clause to handle the exceptions without code duplication.

To create a multi-catch, specify a list of exceptions within a single **catch** clause. You do this by separating each exception type in the list with the OR operator. Each multi-catch parameter is implicitly **final**. (You can explicitly specify **final**, if desired, but it is not necessary.) Because each multi-catch parameter is implicitly **final**, it can't be assigned a new value.

Here is how you can use the multi-catch feature to catch both **ArithmeticException** and **ArrayIndexOutOfBoundsException** with a single **catch** clause: `catch(ArithmeticException | ArrayIndexOutOfBoundsException e) {`

Here is a simple program that demonstrates the use of this multi-catch:
```java
class MultiCatch {
    public static void main(String[] args) {
        int a = 88, b = 0;
        int result;
        char chrs[] = { 'A', 'B', 'C' };

        for (int i = 0; i < 2; i++) {
            try {
                if (i == 0)
                    result = a / b; // generate an ArithmeticException
                else
                    chrs[5] = 'X'; // generate an ArrayIndexOutOfBoundsException
            }
            // This catch clause catches both exceptions
            catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
                System.out.println("Exception caught: " + e);
            }
        }

        System.out.println("After multi-catch.");
    }
}
```

### More Precise Rethrow

The more precise rethrow feature restricts the type of exceptions that can be rethrown to only those checked exceptions that the associated **try** block throws, that are not handled by a preceding **catch** clause, and that are a subtype or supertype of the parameter. While this capability might not be needed often, it is now available for use. For the final rethrow feature to be in force, the **catch** parameter most be effectively **final**. This means that it must not be assigned a new value inside the **catch** block. It can also be explicitly specified as **final**, but this is not necessary.

## Java's Built-in Exceptions

Inside the standard package **java.lang**, Java defines several exception classes. The most general of these exceptions are subclasses of the standard type **RuntimeException**. Since **java.lang** is implicitly imported into all Java programs, many exceptions derived from **RuntimeException** are automatically available. Furthermore, they need not be included in any method's **throws** list. In the language of Java, these are called *unchecked exceptions* because the compiler does not check to see if a method handles or throws these exceptions. The unchecked exceptions defined in *java.lang* are listed in **Table 9-2**. **Table 9-3** lists those exceptions defined by **java.lang** that must be included in a method's **throws** list if that method can generate one of these exceptions and does not handle it itself. These are called *checked exceptions*. In addition to the exceptions in **java.lang**, Java defines several other types of exceptions that relate to other packages, such as **IOException** mentioned earlier.

**Table 9-2** The Unchecked Exceptions Defined in **java.lang**

Exception | Meaning
--------- | -------
ArithmeticException | Arithmetic error, such as integer divide-by-zero.
ArrayIndexOutOfBoundsException | Array index is out-of-bounds.
ArrayStoreException | Assigment to an array element of an incompatible type.
ClassCastException | Invalid cast.
EnumConstantNotPresentException | An attempt is made to use an undefined enumeration value.
IllegalArgumentException | Illegal argument used to invoke a method.
IllegalCallerException | A method cannot be legally executed by the calling code.
IllegalMonitorStateException | Illegal monitor operation, such as waiting on a unlocked thread.
IllegalStateException | Environment or application is in incorrect state.
IllegalThreadStateException | Requested operation not compatible with current thread state.
IndexOutOfBoundsException | Some type of index is out-of-bounds.
LayerInstantiationException | A module layer cannot be created.
NegativeArraySizeException | Array created with a negative size.
NullPointerException | Invalid use of a null reference.
NumberFormatException | Invalid conversion of a string to a numeric format.
SecurityException | Attempt to violate security.
StringIndexOutOfBoundsException | Attempt to index outside the bounds of a string.
TypeNotPresentException | Type not found.
UnsupportedOperationException | An unsupported operation was encountered.

**Table 9-3** The Checked Exceptions Defined in **java.lang**

Exception | Meaning
--------- | -------
ClassNotFoundException | Class not found.
CloneNotSupportedException | Attempt to clone an object that does not implement the **Cloneable** interface.
IllegalAccessException | Attempt to a class is denied.
InstantiationException | Attempt to create an object of an abstract class or interface.
InterruptedException | One thread has been interrupted by another thread.
NoSuchFieldException | A requested field does not exist.
NoSuchMethodException | A requested method does not exist.
ReflectiveOperationException | Superclass of reflection-related exceptions.

**Question: I have heard that Java supports something called** *chained exceptions.* **What are they?**
**Answer**: Chained exceptions were added to Java by JDK 1.4. The chained exception feature allows you to specify one exception as the underlying cause of another. For example, imagine a situation in which a method throws an **ArithmeticException** because of an attempt to divide by zero. However, the actual cause of the problem was that an I/O error occurred, which caused the divisor to be set improperly. Although the method must certainly throw an **ArithmeticException**, since that is the error that occurred, you might also want to let the calling code know that the underlying cause was an I/O error. Chained exceptions let you handle this, and any other situation, in which layers of exceptions exist.

To allow chained exceptions, two constructors and two methods were added to **Throwable**. The constructors are shown here:
```text
Throwable(Throwable causeExc)
Throwable(String msg, Throwable causeExc)
```

In the first form, *causeExc* is the exception that causes the current exception. That is, *causeExc* is the underlying reason that an exception occurred. The second form allows you to specify a description at the same time that you specify a cause exception. These two constructors have also been added to the **Error**, **Exception**, and **RuntimeException** classes.

The chained exception methods added to **Throwable** are **getCause()** and **initCause()**. These methods are shown here:
```text
Throwable getCause()
Throwable initCause(Throwable causeExc)
```

The **getCause()** method returns the exception that underlies the current exception. If there is no underlying exception, **null** is returned. The **initCause()** method associates **causeExc** with the invoking exception and returns a reference to the exception. Thus, you can associate a cause with an exception after the exception has been created. In general, **initCause()** is used to set a cause for legacy exception classes that don't support the two additional constructors described earlier.

Chained exceptions are not something that every program will need. However, in cases in which knowledge of an underlying cause is useful, they offer an elegant solution.

## Creating Exception Subclasses

Part of the power of Java's approach to exceptions is its ability to handle exception types that you create. Through the use of custom exceptions, you can manage errors that relate specifically to your application. Creating an exception class is easy. Just define a subclass of **Exception** (which is, of course, a subclass of **Throwable**). Your subclasses don't need to actually implement anything —it is their existence in the type system that allows you to use them as exceptions.

The **Exception** class does not define any methods of its own. It does, of course, inherit those methods provided by **Throwable**. Thus, all exceptions, including those that you create, have the methods defined by **Throwable** available to them. Of course, you can override one or more of these methods in exception subclasses that you create.

Here is an example that creates an exception called **NonIntResultException**, which is generated when the result of dividing two integer values produces a result with a fractional component. **NonIntResultException** has two fields which hold the integer values; a constructor; and an override of the **toString()** method, allowing the description of the exception to be displayed using **println()**.
```java
class NonIntResultException extends Exception {
    int n;
    int d;

    NonIntResultException(int i, int j) {
        n = i;
        d = j;
    }

    public String toString() {
        return "Result of " + n + " / " + d + " is non-integer.";
    }
}
class CustomExceptDemo {
    public static void main(String[] args) {
        // Here, numer contains some odd values.
        int[] numer = { 4, 8, 15, 32, 64, 127, 256, 512 };
        int[] denom = { 2, 0, 4, 4, 0, 8 };

        for (int i = 0; i < numer.length; i++) {
            try {
                if ((numer[i]%2) != 0)
                    throw new NonIntResultException(numer[i], denom[i]);

                System.out.println(numer[i] + " / " + denom[i] +
                                    " is " + numer[i]/denom[i]);
            }
            catch (ArithmeticException exc) {
                System.out.println("Can't divide by Zero!");
            }
            catch (ArrayIndexOutOfBoundsException exc) {
                System.out.println("No matching element found.");
            }
            catch (NonIntResultException exc) {
                System.out.println(exc);
            }
        }
    }
}
```

The output from the program is shown here:
```text
4 / 2 is 2
Can't divide by Zero!
Result of 15 / 4 is non-integer.
32 / 4 is 8
Can't divide by Zero!
Result of 127 / 8 is non-integer.
No matching element found.
No matching element found.
```

**Question: When should I use exception handling in a program? When should I create my own custom exception classes?**
**Answer**: Since the Java API makes extensive use of exceptions to report errors, nearly all real-world programs will make use of exception handling. This is the part of exception handling that most new Java programmers find easy. It is harder to decide when and how to use your own custom-made exceptions. In general, errors can be reported in two ways: return values and exceptions. When is one approach better than the other? Simply put, in Java, exception handling should be the norm. Certainly, returning an error code is a valid alternative in some cases, but exceptions provide a more powerful, structured way to handle errors. They are the way professional Java programmers handle errors in their code.

[Chapter 10: Using I/O](chapter-10-using-i-o.md#chapter-10-using-io)

[Back to Table of Contents](../README.md#table-of-contents)